/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { io, Tensor, util } from '@tensorflow/tfjs-core';
import { OperationMapper } from '../operations/operation_mapper';
import { GraphExecutor } from './graph_executor';
import { ResourceManager } from './resource_manager';
export const TFHUB_SEARCH_PARAM = '?tfjs-format=file';
export const DEFAULT_MODEL_NAME = 'model.json';
/**
 * A `tf.GraphModel` is a directed, acyclic graph built from a
 * SavedModel GraphDef and allows inference execution.
 *
 * A `tf.GraphModel` can only be created by loading from a model converted from
 * a [TensorFlow SavedModel](https://www.tensorflow.org/guide/saved_model) using
 * the command line converter tool and loaded via `tf.loadGraphModel`.
 *
 * @doc {heading: 'Models', subheading: 'Classes'}
 */
export class GraphModel {
    /**
     * @param modelUrl url for the model, or an `io.IOHandler`.
     * @param weightManifestUrl url for the weight file generated by
     * scripts/convert.py script.
     * @param requestOption options for Request, which allows to send credentials
     * and custom headers.
     * @param onProgress Optional, progress callback function, fired periodically
     * before the load is completed.
     */
    constructor(modelUrl, loadOptions = {}) {
        this.modelUrl = modelUrl;
        this.loadOptions = loadOptions;
        this.version = 'n/a';
        if (loadOptions == null) {
            this.loadOptions = {};
        }
        this.resourceManager = new ResourceManager();
    }
    // Returns the version information for the tensorflow model GraphDef.
    get modelVersion() {
        return this.version;
    }
    get inputNodes() {
        return this.executor.inputNodes;
    }
    get outputNodes() {
        return this.executor.outputNodes;
    }
    get inputs() {
        return this.executor.inputs;
    }
    get outputs() {
        return this.executor.outputs;
    }
    get weights() {
        return this.executor.weightMap;
    }
    get metadata() {
        return this.artifacts.userDefinedMetadata;
    }
    get modelSignature() {
        return this.signature;
    }
    findIOHandler() {
        const path = this.modelUrl;
        if (path.load != null) {
            // Path is an IO Handler.
            this.handler = path;
        }
        else if (this.loadOptions.requestInit != null) {
            this.handler = io.browserHTTPRequest(path, this.loadOptions);
        }
        else {
            const handlers = io.getLoadHandlers(path, this.loadOptions);
            if (handlers.length === 0) {
                // For backward compatibility: if no load handler can be found,
                // assume it is a relative http path.
                handlers.push(io.browserHTTPRequest(path, this.loadOptions));
            }
            else if (handlers.length > 1) {
                throw new Error(`Found more than one (${handlers.length}) load handlers for ` +
                    `URL '${[path]}'`);
            }
            this.handler = handlers[0];
        }
    }
    /**
     * Loads the model and weight files, construct the in memory weight map and
     * compile the inference graph.
     */
    load() {
        this.findIOHandler();
        if (this.handler.load == null) {
            throw new Error('Cannot proceed with model loading because the IOHandler provided ' +
                'does not have the `load` method implemented.');
        }
        const loadResult = this.handler.load();
        if (util.isPromise(loadResult)) {
            return loadResult.then(artifacts => this.loadSync(artifacts));
        }
        return this.loadSync(loadResult);
    }
    /**
     * Synchronously construct the in memory weight map and
     * compile the inference graph. Also initialize hashtable if any.
     *
     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
     */
    loadSync(artifacts) {
        this.artifacts = artifacts;
        const graph = this.artifacts.modelTopology;
        let signature;
        if (this.artifacts.userDefinedMetadata != null &&
            this.artifacts.userDefinedMetadata.signature != null) {
            signature = // tslint:disable-next-line:no-any
                this.artifacts.userDefinedMetadata.signature;
        }
        else {
            signature = this.artifacts.signature;
        }
        this.signature = signature;
        this.version = `${graph.versions.producer}.${graph.versions.minConsumer}`;
        const weightMap = io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
        this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph, this.signature));
        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
        // Attach a model-level resourceManager to each executor to share resources,
        // such as `HashTable`.
        this.executor.resourceManager = this.resourceManager;
        if (artifacts.modelInitializer != null &&
            artifacts.modelInitializer.node != null) {
            const initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);
            this.initializer = new GraphExecutor(initializer);
            this.initializer.weightMap = this.executor.weightMap;
            // Attach a model-level resourceManager to the initializer, the
            // hashTables created from when executing the initializer will be stored
            // in the resourceManager.
            this.initializer.resourceManager = this.resourceManager;
            this.initializer.executeAsync({}, []);
        }
        return true;
    }
    /**
     * Save the configuration and/or weights of the GraphModel.
     *
     * An `IOHandler` is an object that has a `save` method of the proper
     * signature defined. The `save` method manages the storing or
     * transmission of serialized data ("artifacts") that represent the
     * model's topology and weights onto or via a specific medium, such as
     * file downloads, local storage, IndexedDB in the web browser and HTTP
     * requests to a server. TensorFlow.js provides `IOHandler`
     * implementations for a number of frequently used saving mediums, such as
     * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
     * for more details.
     *
     * This method also allows you to refer to certain types of `IOHandler`s
     * as URL-like string shortcuts, such as 'localstorage://' and
     * 'indexeddb://'.
     *
     * Example 1: Save `model`'s topology and weights to browser [local
     * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
     * then load it back.
     *
     * ```js
     * const modelUrl =
     *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
     * const model = await tf.loadGraphModel(modelUrl);
     * const zeros = tf.zeros([1, 224, 224, 3]);
     * model.predict(zeros).print();
     *
     * const saveResults = await model.save('localstorage://my-model-1');
     *
     * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
     * console.log('Prediction from loaded model:');
     * model.predict(zeros).print();
     * ```
     *
     * @param handlerOrURL An instance of `IOHandler` or a URL-like,
     * scheme-based string shortcut for `IOHandler`.
     * @param config Options for saving the model.
     * @returns A `Promise` of `SaveResult`, which summarizes the result of
     * the saving, such as byte sizes of the saved artifacts for the model's
     *   topology and weight values.
     *
     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
     */
    async save(handlerOrURL, config) {
        if (typeof handlerOrURL === 'string') {
            const handlers = io.getSaveHandlers(handlerOrURL);
            if (handlers.length === 0) {
                throw new Error(`Cannot find any save handlers for URL '${handlerOrURL}'`);
            }
            else if (handlers.length > 1) {
                throw new Error(`Found more than one (${handlers.length}) save handlers for ` +
                    `URL '${handlerOrURL}'`);
            }
            handlerOrURL = handlers[0];
        }
        if (handlerOrURL.save == null) {
            throw new Error('GraphModel.save() cannot proceed because the IOHandler ' +
                'provided does not have the `save` attribute defined.');
        }
        return handlerOrURL.save(this.artifacts);
    }
    /**
     * Execute the inference for the input tensors.
     *
     * @param input The input tensors, when there is single input for the model,
     * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
     * inputs params should be in either `tf.Tensor`[] if the input order is
     * fixed, or otherwise NamedTensorMap format.
     *
     * For model with multiple inputs, we recommend you use NamedTensorMap as the
     * input type, if you use `tf.Tensor`[], the order of the array needs to
     * follow the
     * order of inputNodes array. @see {@link GraphModel.inputNodes}
     *
     * You can also feed any intermediate nodes using the NamedTensorMap as the
     * input type. For example, given the graph
     *    InputNode => Intermediate => OutputNode,
     * you can execute the subgraph Intermediate => OutputNode by calling
     *    model.execute('IntermediateNode' : tf.tensor(...));
     *
     * This is useful for models that uses tf.dynamic_rnn, where the intermediate
     * state needs to be fed manually.
     *
     * For batch inference execution, the tensors for each input need to be
     * concatenated together. For example with mobilenet, the required input shape
     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
     * If we are provide a batched data of 100 images, the input tensor should be
     * in the shape of [100, 244, 244, 3].
     *
     * @param config Prediction configuration for specifying the batch size and
     * output node names. Currently the batch size option is ignored for graph
     * model.
     *
     * @returns Inference result tensors. The output would be single `tf.Tensor`
     * if model has single output node, otherwise Tensor[] or NamedTensorMap[]
     * will be returned for model with multiple outputs.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    predict(inputs, config) {
        return this.execute(inputs, this.outputNodes);
    }
    normalizeInputs(inputs) {
        if (!(inputs instanceof Tensor) && !Array.isArray(inputs)) {
            // The input is already a NamedTensorMap.
            return inputs;
        }
        inputs = Array.isArray(inputs) ? inputs : [inputs];
        if (inputs.length !== this.inputNodes.length) {
            throw new Error('Input tensor count mismatch,' +
                `the graph model has ${this.inputNodes.length} placeholders, ` +
                `while there are ${inputs.length} input tensors.`);
        }
        return this.inputNodes.reduce((map, inputName, i) => {
            map[inputName] = inputs[i];
            return map;
        }, {});
    }
    normalizeOutputs(outputs) {
        outputs = outputs || this.outputNodes;
        return !Array.isArray(outputs) ? [outputs] : outputs;
    }
    /**
     * Executes inference for the model for given input tensors.
     * @param inputs tensor, tensor array or tensor map of the inputs for the
     * model, keyed by the input node names.
     * @param outputs output node name from the Tensorflow model, if no
     * outputs are specified, the default outputs of the model would be used.
     * You can inspect intermediate nodes of the model by adding them to the
     * outputs array.
     *
     * @returns A single tensor if provided with a single output or no outputs
     * are provided and there is only one default output, otherwise return a
     * tensor array. The order of the tensor array is the same as the outputs
     * if provided, otherwise the order of outputNodes attribute of the model.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    execute(inputs, outputs) {
        inputs = this.normalizeInputs(inputs);
        outputs = this.normalizeOutputs(outputs);
        const result = this.executor.execute(inputs, outputs);
        return result.length > 1 ? result : result[0];
    }
    /**
     * Executes inference for the model for given input tensors in async
     * fashion, use this method when your model contains control flow ops.
     * @param inputs tensor, tensor array or tensor map of the inputs for the
     * model, keyed by the input node names.
     * @param outputs output node name from the Tensorflow model, if no outputs
     * are specified, the default outputs of the model would be used. You can
     * inspect intermediate nodes of the model by adding them to the outputs
     * array.
     *
     * @returns A Promise of single tensor if provided with a single output or
     * no outputs are provided and there is only one default output, otherwise
     * return a tensor map.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    async executeAsync(inputs, outputs) {
        inputs = this.normalizeInputs(inputs);
        outputs = this.normalizeOutputs(outputs);
        const result = await this.executor.executeAsync(inputs, outputs);
        return result.length > 1 ? result : result[0];
    }
    /**
     * Get intermediate tensors for model debugging mode (flag
     * KEEP_INTERMEDIATE_TENSORS is true).
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    getIntermediateTensors() {
        return this.executor.getIntermediateTensors();
    }
    /**
     * Dispose intermediate tensors for model debugging mode (flag
     * KEEP_INTERMEDIATE_TENSORS is true).
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    disposeIntermediateTensors() {
        this.executor.disposeIntermediateTensors();
    }
    convertTensorMapToTensorsMap(map) {
        return Object.keys(map).reduce((newMap, key) => {
            newMap[key] = [map[key]];
            return newMap;
        }, {});
    }
    /**
     * Releases the memory used by the weight tensors and resourceManager.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    dispose() {
        this.executor.dispose();
        if (this.initializer) {
            this.initializer.dispose();
        }
        this.resourceManager.dispose();
    }
}
/**
 * Load a graph model given a URL to the model definition.
 *
 * Example of loading MobileNetV2 from a URL and making a prediction with a
 * zeros input:
 *
 * ```js
 * const modelUrl =
 *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
 * const model = await tf.loadGraphModel(modelUrl);
 * const zeros = tf.zeros([1, 224, 224, 3]);
 * model.predict(zeros).print();
 * ```
 *
 * Example of loading MobileNetV2 from a TF Hub URL and making a prediction with
 * a zeros input:
 *
 * ```js
 * const modelUrl =
 *    'https://tfhub.dev/google/imagenet/mobilenet_v2_140_224/classification/2';
 * const model = await tf.loadGraphModel(modelUrl, {fromTFHub: true});
 * const zeros = tf.zeros([1, 224, 224, 3]);
 * model.predict(zeros).print();
 * ```
 * @param modelUrl The url or an `io.IOHandler` that loads the model.
 * @param options Options for the HTTP request, which allows to send credentials
 *    and custom headers.
 *
 * @doc {heading: 'Models', subheading: 'Loading'}
 */
export async function loadGraphModel(modelUrl, options = {}) {
    if (modelUrl == null) {
        throw new Error('modelUrl in loadGraphModel() cannot be null. Please provide a url ' +
            'or an IOHandler that loads the model');
    }
    if (options == null) {
        options = {};
    }
    if (options.fromTFHub && typeof modelUrl === 'string') {
        modelUrl = getTFHubUrl(modelUrl);
    }
    const model = new GraphModel(modelUrl, options);
    await model.load();
    return model;
}
/**
 * Load a graph model given a synchronous IO handler with a 'load' method.
 *
 * @param modelSource The `io.IOHandlerSync` that loads the model.
 *
 * @doc {heading: 'Models', subheading: 'Loading'}
 */
export function loadGraphModelSync(modelSource) {
    if (modelSource == null) {
        throw new Error('modelUrl in loadGraphModelSync() cannot be null. Please provide a ' +
            'url or an IOHandler that loads the model');
    }
    if (!modelSource.load) {
        throw new Error(`modelUrl IO Handler ${modelSource} has no load function`);
    }
    const model = new GraphModel(modelSource);
    model.load();
    return model;
}
function getTFHubUrl(modelUrl) {
    if (!modelUrl.endsWith('/')) {
        modelUrl = (modelUrl) + '/';
    }
    return `${modelUrl}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGhfbW9kZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvbnZlcnRlci9zcmMvZXhlY3V0b3IvZ3JhcGhfbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFpQixFQUFFLEVBQXNDLE1BQU0sRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUkzRyxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sZ0NBQWdDLENBQUM7QUFFL0QsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBQy9DLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxtQkFBbUIsQ0FBQztBQUN0RCxNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxZQUFZLENBQUM7QUFJL0M7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxPQUFPLFVBQVU7SUEyQ3JCOzs7Ozs7OztPQVFHO0lBQ0gsWUFDWSxRQUFrQixFQUNsQixjQUE4QixFQUFFO1FBRGhDLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsZ0JBQVcsR0FBWCxXQUFXLENBQXFCO1FBbkRwQyxZQUFPLEdBQUcsS0FBSyxDQUFDO1FBb0R0QixJQUFJLFdBQVcsSUFBSSxJQUFJLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7U0FDdkI7UUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksZUFBZSxFQUFFLENBQUM7SUFDL0MsQ0FBQztJQWpERCxxRUFBcUU7SUFDckUsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFFRCxJQUFJLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDO0lBQ2xDLENBQUM7SUFFRCxJ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QUNmLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFFSCxNQUFNLFVBQVUsa0JBQWtCLENBQ2hDLFdBQTZCO0lBQzdCLElBQUksV0FBVyxJQUFJLElBQUksRUFBRTtRQUN2QixNQUFNLElBQUksS0FBSyxDQUNYLG9FQUFvRTtZQUNwRSwwQ0FBMEMsQ0FBQyxDQUFDO0tBQ2pEO0lBQ0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUU7UUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsV0FBVyx1QkFBdUIsQ0FBQyxDQUFDO0tBQzVFO0lBQ0QsTUFBTSxLQUFLLEdBQUcsSUFBSSxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFMUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2IsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsUUFBZ0I7SUFDbkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDM0IsUUFBUSxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsR0FBRyxDQUFDO0tBQzdCO0lBQ0QsT0FBTyxHQUFHLFFBQVEsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsRUFBRSxDQUFDO0FBQ2pFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7SW5mZXJlbmNlTW9kZWwsIGlvLCBNb2RlbFByZWRpY3RDb25maWcsIE5hbWVkVGVuc29yTWFwLCBUZW5zb3IsIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCAqIGFzIHRlbnNvcmZsb3cgZnJvbSAnLi4vZGF0YS9jb21waWxlZF9hcGknO1xuaW1wb3J0IHtOYW1lZFRlbnNvcnNNYXAsIFRlbnNvckluZm99IGZyb20gJy4uL2RhdGEvdHlwZXMnO1xuaW1wb3J0IHtPcGVyYXRpb25NYXBwZXJ9IGZyb20gJy4uL29wZXJhdGlvbnMvb3BlcmF0aW9uX21hcHBlcic7XG5cbmltcG9ydCB7R3JhcGhFeGVjdXRvcn0gZnJvbSAnLi9ncmFwaF9leGVjdXRvcic7XG5pbXBvcnQge1Jlc291cmNlTWFuYWdlcn0gZnJvbSAnLi9yZXNvdXJjZV9tYW5hZ2VyJztcblxuZXhwb3J0IGNvbnN0IFRGSFVCX1NFQVJDSF9QQVJBTSA9ICc/dGZqcy1mb3JtYXQ9ZmlsZSc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9NT0RFTF9OQU1FID0gJ21vZGVsLmpzb24nO1xudHlwZSBVcmwgPSBzdHJpbmcgfCBpby5JT0hhbmRsZXIgfCBpby5JT0hhbmRsZXJTeW5jO1xudHlwZSBVcmxJT0hhbmRsZXI8VCBleHRlbmRzIFVybD4gPSBUIGV4dGVuZHMgc3RyaW5nID8gaW8uSU9IYW5kbGVyIDogVDtcblxuLyoqXG4gKiBBIGB0Zi5HcmFwaE1vZGVsYCBpcyBhIGRpcmVjdGVkLCBhY3ljbGljIGdyYXBoIGJ1aWx0IGZyb20gYVxuICogU2F2ZWRNb2RlbCBHcmFwaERlZiBhbmQgYWxsb3dzIGluZmVyZW5jZSBleGVjdXRpb24uXG4gKlxuICogQSBgdGYuR3JhcGhNb2RlbGAgY2FuIG9ubHkgYmUgY3JlYXRlZCBieSBsb2FkaW5nIGZyb20gYSBtb2RlbCBjb252ZXJ0ZWQgZnJvbVxuICogYSBbVGVuc29yRmxvdyBTYXZlZE1vZGVsXShodHRwczovL3d3dy50ZW5zb3JmbG93Lm9yZy9ndWlkZS9zYXZlZF9tb2RlbCkgdXNpbmdcbiAqIHRoZSBjb21tYW5kIGxpbmUgY29udmVydGVyIHRvb2wgYW5kIGxvYWRlZCB2aWEgYHRmLmxvYWRHcmFwaE1vZGVsYC5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICovXG5leHBvcnQgY2xhc3MgR3JhcGhNb2RlbDxNb2RlbFVSTCBleHRlbmRzIFVybCA9IHN0cmluZ3xpby5JT0hhbmRsZXI+XG4gIGltcGxlbWVudHMgSW5mZXJlbmNlTW9kZWwge1xuICBwcml2YXRlIGV4ZWN1dG9yOiBHcmFwaEV4ZWN1dG9yO1xuICBwcml2YXRlIHZlcnNpb24gPSAnbi9hJztcbiAgcHJpdmF0ZSBoYW5kbGVyOiBVcmxJT0hhbmRsZXI8TW9kZWxVUkw+O1xuICBwcml2YXRlIGFydGlmYWN0czogaW8uTW9kZWxBcnRpZmFjdHM7XG4gIHByaXZhdGUgaW5pdGlhbGl6ZXI6IEdyYXBoRXhlY3V0b3I7XG4gIHByaXZhdGUgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG4gIHByaXZhdGUgc2lnbmF0dXJlOiB0ZW5zb3JmbG93LklTaWduYXR1cmVEZWY7XG5cbiAgLy8gUmV0dXJucyB0aGUgdmVyc2lvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHRlbnNvcmZsb3cgbW9kZWwgR3JhcGhEZWYuXG4gIGdldCBtb2RlbFZlcnNpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICB9XG5cbiAgZ2V0IGlucHV0Tm9kZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLmlucHV0Tm9kZXM7XG4gIH1cblxuICBnZXQgb3V0cHV0Tm9kZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dE5vZGVzO1xuICB9XG5cbiAgZ2V0IGlucHV0cygpOiBUZW5zb3JJbmZvW10ge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLmlucHV0cztcbiAgfVxuXG4gIGdldCBvdXRwdXRzKCk6IFRlbnNvckluZm9bXSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0b3Iub3V0cHV0cztcbiAgfVxuXG4gIGdldCB3ZWlnaHRzKCk6IE5hbWVkVGVuc29yc01hcCB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0b3Iud2VpZ2h0TWFwO1xuICB9XG5cbiAgZ2V0IG1ldGFkYXRhKCk6IHt9IHtcbiAgICByZXR1cm4gdGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YTtcbiAgfVxuXG4gIGdldCBtb2RlbFNpZ25hdHVyZSgpOiB7fSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBtb2RlbFVybCB1cmwgZm9yIHRoZSBtb2RlbCwgb3IgYW4gYGlvLklPSGFuZGxlcmAuXG4gICAqIEBwYXJhbSB3ZWlnaHRNYW5pZmVzdFVybCB1cmwgZm9yIHRoZSB3ZWlnaHQgZmlsZSBnZW5lcmF0ZWQgYnlcbiAgICogc2NyaXB0cy9jb252ZXJ0LnB5IHNjcmlwdC5cbiAgICogQHBhcmFtIHJlcXVlc3RPcHRpb24gb3B0aW9ucyBmb3IgUmVxdWVzdCwgd2hpY2ggYWxsb3dzIHRvIHNlbmQgY3JlZGVudGlhbHNcbiAgICogYW5kIGN1c3RvbSBoZWFkZXJzLlxuICAgKiBAcGFyYW0gb25Qcm9ncmVzcyBPcHRpb25hbCwgcHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24sIGZpcmVkIHBlcmlvZGljYWxseVxuICAgKiBiZWZvcmUgdGhlIGxvYWQgaXMgY29tcGxldGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIG1vZGVsVXJsOiBNb2RlbFVSTCxcbiAgICAgIHByaXZhdGUgbG9hZE9wdGlvbnM6IGlvLkxvYWRPcHRpb25zID0ge30pIHtcbiAgICBpZiAobG9hZE9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2FkT3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IG5ldyBSZXNvdXJjZU1hbmFnZXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZElPSGFuZGxlcigpIHtcbiAgICB0eXBlIElPSGFuZGxlciA9IFVybElPSGFuZGxlcjxNb2RlbFVSTD47XG4gICAgY29uc3QgcGF0aCA9IHRoaXMubW9kZWxVcmw7XG4gICAgaWYgKChwYXRoIGFzIGlvLklPSGFuZGxlcikubG9hZCAhPSBudWxsKSB7XG4gICAgICAvLyBQYXRoIGlzIGFuIElPIEhhbmRsZXIuXG4gICAgICB0aGlzLmhhbmRsZXIgPSBwYXRoIGFzIElPSGFuZGxlcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMubG9hZE9wdGlvbnMucmVxdWVzdEluaXQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oYW5kbGVyID0gaW8uYnJvd3NlckhUVFBSZXF1ZXN0KHBhdGggYXMgc3RyaW5nLCB0aGlzLmxvYWRPcHRpb25zKSBhc1xuICAgICAgSU9IYW5kbGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYW5kbGVycyA9IGlvLmdldExvYWRIYW5kbGVycyhwYXRoIGFzIHN0cmluZywgdGhpcy5sb2FkT3B0aW9ucyk7XG4gICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBpZiBubyBsb2FkIGhhbmRsZXIgY2FuIGJlIGZvdW5kLFxuICAgICAgICAvLyBhc3N1bWUgaXQgaXMgYSByZWxhdGl2ZSBodHRwIHBhdGguXG4gICAgICAgIGhhbmRsZXJzLnB1c2goaW8uYnJvd3NlckhUVFBSZXF1ZXN0KHBhdGggYXMgc3RyaW5nLCB0aGlzLmxvYWRPcHRpb25zKSk7XG4gICAgICB9IGVsc2UgaWYgKGhhbmRsZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIG1vcmUgdGhhbiBvbmUgKCR7aGFuZGxlcnMubGVuZ3RofSkgbG9hZCBoYW5kbGVycyBmb3IgYCArXG4gICAgICAgICAgICBgVVJMICcke1twYXRoXX0nYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyc1swXSBhcyBJT0hhbmRsZXI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBtb2RlbCBhbmQgd2VpZ2h0IGZpbGVzLCBjb25zdHJ1Y3QgdGhlIGluIG1lbW9yeSB3ZWlnaHQgbWFwIGFuZFxuICAgKiBjb21waWxlIHRoZSBpbmZlcmVuY2UgZ3JhcGguXG4gICAqL1xuICBsb2FkKCk6IFVybElPSGFuZGxlcjxNb2RlbFVSTD4gZXh0ZW5kcyBpby5JT0hhbmRsZXJTeW5jID8gYm9vbGVhblxuICAgIDogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHlwZSBJT0hhbmRsZXIgPSBVcmxJT0hhbmRsZXI8TW9kZWxVUkw+O1xuICAgIHRoaXMuZmluZElPSGFuZGxlcigpO1xuICAgIGlmICh0aGlzLmhhbmRsZXIubG9hZCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgJyArXG4gICAgICAgICAgJ2RvZXMgbm90IGhhdmUgdGhlIGBsb2FkYCBtZXRob2QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuXG4gICAgdHlwZSBSZXN1bHQgPSBJT0hhbmRsZXIgZXh0ZW5kcyBpby5JT0hhbmRsZXJTeW5jID8gYm9vbGVhblxuICAgICAgOiBQcm9taXNlPGJvb2xlYW4+O1xuXG4gICAgY29uc3QgbG9hZFJlc3VsdCA9IHRoaXMuaGFuZGxlci5sb2FkKCkgYXMgUmV0dXJuVHlwZTxJT0hhbmRsZXJbJ2xvYWQnXT47XG4gICAgaWYgKHV0aWwuaXNQcm9taXNlKGxvYWRSZXN1bHQpKSB7XG4gICAgICByZXR1cm4gbG9hZFJlc3VsdC50aGVuKGFydGlmYWN0cyA9PiB0aGlzLmxvYWRTeW5jKGFydGlmYWN0cykpIGFzIFJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2FkU3luYyhsb2FkUmVzdWx0KSBhcyBSZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXNseSBjb25zdHJ1Y3QgdGhlIGluIG1lbW9yeSB3ZWlnaHQgbWFwIGFuZFxuICAgKiBjb21waWxlIHRoZSBpbmZlcmVuY2UgZ3JhcGguIEFsc28gaW5pdGlhbGl6ZSBoYXNodGFibGUgaWYgYW55LlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnLCBpZ25vcmVDSTogdHJ1ZX1cbiAgICovXG4gIGxvYWRTeW5jKGFydGlmYWN0czogaW8uTW9kZWxBcnRpZmFjdHMpIHtcbiAgICB0aGlzLmFydGlmYWN0cyA9IGFydGlmYWN0cztcbiAgICBjb25zdCBncmFwaCA9IHRoaXMuYXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3kgYXMgdGVuc29yZmxvdy5JR3JhcGhEZWY7XG5cbiAgICBsZXQgc2lnbmF0dXJlO1xuICAgIGlmICh0aGlzLmFydGlmYWN0cy51c2VyRGVmaW5lZE1ldGFkYXRhICE9IG51bGwgJiZcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YS5zaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgc2lnbmF0dXJlID0gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAodGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSBhcyBhbnkpLnNpZ25hdHVyZSBhc1xuICAgICAgICAgIHRlbnNvcmZsb3cuSVNpZ25hdHVyZURlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmF0dXJlID0gdGhpcy5hcnRpZmFjdHMuc2lnbmF0dXJlO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcblxuICAgIHRoaXMudmVyc2lvbiA9IGAke2dyYXBoLnZlcnNpb25zLnByb2R1Y2VyfS4ke2dyYXBoLnZlcnNpb25zLm1pbkNvbnN1bWVyfWA7XG4gICAgY29uc3Qgd2VpZ2h0TWFwID1cbiAgICAgICAgaW8uZGVjb2RlV2VpZ2h0cyh0aGlzLmFydGlmYWN0cy53ZWlnaHREYXRhLCB0aGlzLmFydGlmYWN0cy53ZWlnaHRTcGVjcyk7XG4gICAgdGhpcy5leGVjdXRvciA9IG5ldyBHcmFwaEV4ZWN1dG9yKFxuICAgICAgICBPcGVyYXRpb25NYXBwZXIuSW5zdGFuY2UudHJhbnNmb3JtR3JhcGgoZ3JhcGgsIHRoaXMuc2lnbmF0dXJlKSk7XG4gICAgdGhpcy5leGVjdXRvci53ZWlnaHRNYXAgPSB0aGlzLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAod2VpZ2h0TWFwKTtcbiAgICAvLyBBdHRhY2ggYSBtb2RlbC1sZXZlbCByZXNvdXJjZU1hbmFnZXIgdG8gZWFjaCBleGVjdXRvciB0byBzaGFyZSByZXNvdXJjZXMsXG4gICAgLy8gc3VjaCBhcyBgSGFzaFRhYmxlYC5cbiAgICB0aGlzLmV4ZWN1dG9yLnJlc291cmNlTWFuYWdlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyO1xuXG4gICAgaWYgKGFydGlmYWN0cy5tb2RlbEluaXRpYWxpemVyICE9IG51bGwgJiZcbiAgICAgICAgKGFydGlmYWN0cy5tb2RlbEluaXRpYWxpemVyIGFzIHRlbnNvcmZsb3cuSUdyYXBoRGVmKS5ub2RlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxpemVyID1cbiAgICAgICAgICBPcGVyYXRpb25NYXBwZXIuSW5zdGFuY2UudHJhbnNmb3JtR3JhcGgoYXJ0aWZhY3RzLm1vZGVsSW5pdGlhbGl6ZXIpO1xuICAgICAgdGhpcy5pbml0aWFsaXplciA9IG5ldyBHcmFwaEV4ZWN1dG9yKGluaXRpYWxpemVyKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIud2VpZ2h0TWFwID0gdGhpcy5leGVjdXRvci53ZWlnaHRNYXA7XG4gICAgICAvLyBBdHRhY2ggYSBtb2RlbC1sZXZlbCByZXNvdXJjZU1hbmFnZXIgdG8gdGhlIGluaXRpYWxpemVyLCB0aGVcbiAgICAgIC8vIGhhc2hUYWJsZXMgY3JlYXRlZCBmcm9tIHdoZW4gZXhlY3V0aW5nIHRoZSBpbml0aWFsaXplciB3aWxsIGJlIHN0b3JlZFxuICAgICAgLy8gaW4gdGhlIHJlc291cmNlTWFuYWdlci5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIucmVzb3VyY2VNYW5hZ2VyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXI7XG4gICAgICB0aGlzLmluaXRpYWxpemVyLmV4ZWN1dGVBc3luYyh7fSwgW10pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgdGhlIGNvbmZpZ3VyYXRpb24gYW5kL29yIHdlaWdodHMgb2YgdGhlIEdyYXBoTW9kZWwuXG4gICAqXG4gICAqIEFuIGBJT0hhbmRsZXJgIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBhIGBzYXZlYCBtZXRob2Qgb2YgdGhlIHByb3BlclxuICAgKiBzaWduYXR1cmUgZGVmaW5lZC4gVGhlIGBzYXZlYCBtZXRob2QgbWFuYWdlcyB0aGUgc3RvcmluZyBvclxuICAgKiB0cmFuc21pc3Npb24gb2Ygc2VyaWFsaXplZCBkYXRhIChcImFydGlmYWN0c1wiKSB0aGF0IHJlcHJlc2VudCB0aGVcbiAgICogbW9kZWwncyB0b3BvbG9neSBhbmQgd2VpZ2h0cyBvbnRvIG9yIHZpYSBhIHNwZWNpZmljIG1lZGl1bSwgc3VjaCBhc1xuICAgKiBmaWxlIGRvd25sb2FkcywgbG9jYWwgc3RvcmFnZSwgSW5kZXhlZERCIGluIHRoZSB3ZWIgYnJvd3NlciBhbmQgSFRUUFxuICAgKiByZXF1ZXN0cyB0byBhIHNlcnZlci4gVGVuc29yRmxvdy5qcyBwcm92aWRlcyBgSU9IYW5kbGVyYFxuICAgKiBpbXBsZW1lbnRhdGlvbnMgZm9yIGEgbnVtYmVyIG9mIGZyZXF1ZW50bHkgdXNlZCBzYXZpbmcgbWVkaXVtcywgc3VjaCBhc1xuICAgKiBgdGYuaW8uYnJvd3NlckRvd25sb2Fkc2AgYW5kIGB0Zi5pby5icm93c2VyTG9jYWxTdG9yYWdlYC4gU2VlIGB0Zi5pb2BcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYWxzbyBhbGxvd3MgeW91IHRvIHJlZmVyIHRvIGNlcnRhaW4gdHlwZXMgb2YgYElPSGFuZGxlcmBzXG4gICAqIGFzIFVSTC1saWtlIHN0cmluZyBzaG9ydGN1dHMsIHN1Y2ggYXMgJ2xvY2Fsc3RvcmFnZTovLycgYW5kXG4gICAqICdpbmRleGVkZGI6Ly8nLlxuICAgKlxuICAgKiBFeGFtcGxlIDE6IFNhdmUgYG1vZGVsYCdzIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIHRvIGJyb3dzZXIgW2xvY2FsXG4gICAqIHN0b3JhZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvbG9jYWxTdG9yYWdlKTtcbiAgICogdGhlbiBsb2FkIGl0IGJhY2suXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1vZGVsVXJsID1cbiAgICogICAgJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS90ZmpzLW1vZGVscy9zYXZlZG1vZGVsL21vYmlsZW5ldF92Ml8xLjBfMjI0L21vZGVsLmpzb24nO1xuICAgKiBjb25zdCBtb2RlbCA9IGF3YWl0IHRmLmxvYWRHcmFwaE1vZGVsKG1vZGVsVXJsKTtcbiAgICogY29uc3QgemVyb3MgPSB0Zi56ZXJvcyhbMSwgMjI0LCAyMjQsIDNdKTtcbiAgICogbW9kZWwucHJlZGljdCh6ZXJvcykucHJpbnQoKTtcbiAgICpcbiAgICogY29uc3Qgc2F2ZVJlc3VsdHMgPSBhd2FpdCBtb2RlbC5zYXZlKCdsb2NhbHN0b3JhZ2U6Ly9teS1tb2RlbC0xJyk7XG4gICAqXG4gICAqIGNvbnN0IGxvYWRlZE1vZGVsID0gYXdhaXQgdGYubG9hZEdyYXBoTW9kZWwoJ2xvY2Fsc3RvcmFnZTovL215LW1vZGVsLTEnKTtcbiAgICogY29uc29sZS5sb2coJ1ByZWRpY3Rpb24gZnJvbSBsb2FkZWQgbW9kZWw6Jyk7XG4gICAqIG1vZGVsLnByZWRpY3QoemVyb3MpLnByaW50KCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gaGFuZGxlck9yVVJMIEFuIGluc3RhbmNlIG9mIGBJT0hhbmRsZXJgIG9yIGEgVVJMLWxpa2UsXG4gICAqIHNjaGVtZS1iYXNlZCBzdHJpbmcgc2hvcnRjdXQgZm9yIGBJT0hhbmRsZXJgLlxuICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbnMgZm9yIHNhdmluZyB0aGUgbW9kZWwuXG4gICAqIEByZXR1cm5zIEEgYFByb21pc2VgIG9mIGBTYXZlUmVzdWx0YCwgd2hpY2ggc3VtbWFyaXplcyB0aGUgcmVzdWx0IG9mXG4gICAqIHRoZSBzYXZpbmcsIHN1Y2ggYXMgYnl0ZSBzaXplcyBvZiB0aGUgc2F2ZWQgYXJ0aWZhY3RzIGZvciB0aGUgbW9kZWwnc1xuICAgKiAgIHRvcG9sb2d5IGFuZCB3ZWlnaHQgdmFsdWVzLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnLCBpZ25vcmVDSTogdHJ1ZX1cbiAgICovXG4gIGFzeW5jIHNhdmUoaGFuZGxlck9yVVJMOiBpby5JT0hhbmRsZXJ8c3RyaW5nLCBjb25maWc/OiBpby5TYXZlQ29uZmlnKTpcbiAgICAgIFByb21pc2U8aW8uU2F2ZVJlc3VsdD4ge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlck9yVVJMID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSBpby5nZXRTYXZlSGFuZGxlcnMoaGFuZGxlck9yVVJMKTtcbiAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBmaW5kIGFueSBzYXZlIGhhbmRsZXJzIGZvciBVUkwgJyR7aGFuZGxlck9yVVJMfSdgKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRm91bmQgbW9yZSB0aGFuIG9uZSAoJHtoYW5kbGVycy5sZW5ndGh9KSBzYXZlIGhhbmRsZXJzIGZvciBgICtcbiAgICAgICAgICAgIGBVUkwgJyR7aGFuZGxlck9yVVJMfSdgKTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXJPclVSTCA9IGhhbmRsZXJzWzBdO1xuICAgIH1cbiAgICBpZiAoaGFuZGxlck9yVVJMLnNhdmUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdHcmFwaE1vZGVsLnNhdmUoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgJyArXG4gICAgICAgICAgJ3Byb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBzYXZlYCBhdHRyaWJ1dGUgZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlck9yVVJMLnNhdmUodGhpcy5hcnRpZmFjdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIGluZmVyZW5jZSBmb3IgdGhlIGlucHV0IHRlbnNvcnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdGVuc29ycywgd2hlbiB0aGVyZSBpcyBzaW5nbGUgaW5wdXQgZm9yIHRoZSBtb2RlbCxcbiAgICogaW5wdXRzIHBhcmFtIHNob3VsZCBiZSBhIGB0Zi5UZW5zb3JgLiBGb3IgbW9kZWxzIHdpdGggbXV0bGlwbGUgaW5wdXRzLFxuICAgKiBpbnB1dHMgcGFyYW1zIHNob3VsZCBiZSBpbiBlaXRoZXIgYHRmLlRlbnNvcmBbXSBpZiB0aGUgaW5wdXQgb3JkZXIgaXNcbiAgICogZml4ZWQsIG9yIG90aGVyd2lzZSBOYW1lZFRlbnNvck1hcCBmb3JtYXQuXG4gICAqXG4gICAqIEZvciBtb2RlbCB3aXRoIG11bHRpcGxlIGlucHV0cywgd2UgcmVjb21tZW5kIHlvdSB1c2UgTmFtZWRUZW5zb3JNYXAgYXMgdGhlXG4gICAqIGlucHV0IHR5cGUsIGlmIHlvdSB1c2UgYHRmLlRlbnNvcmBbXSwgdGhlIG9yZGVyIG9mIHRoZSBhcnJheSBuZWVkcyB0b1xuICAgKiBmb2xsb3cgdGhlXG4gICAqIG9yZGVyIG9mIGlucHV0Tm9kZXMgYXJyYXkuIEBzZWUge0BsaW5rIEdyYXBoTW9kZWwuaW5wdXROb2Rlc31cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGZlZWQgYW55IGludGVybWVkaWF0ZSBub2RlcyB1c2luZyB0aGUgTmFtZWRUZW5zb3JNYXAgYXMgdGhlXG4gICAqIGlucHV0IHR5cGUuIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgZ3JhcGhcbiAgICogICAgSW5wdXROb2RlID0+IEludGVybWVkaWF0ZSA9PiBPdXRwdXROb2RlLFxuICAgKiB5b3UgY2FuIGV4ZWN1dGUgdGhlIHN1YmdyYXBoIEludGVybWVkaWF0ZSA9PiBPdXRwdXROb2RlIGJ5IGNhbGxpbmdcbiAgICogICAgbW9kZWwuZXhlY3V0ZSgnSW50ZXJtZWRpYXRlTm9kZScgOiB0Zi50ZW5zb3IoLi4uKSk7XG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBtb2RlbHMgdGhhdCB1c2VzIHRmLmR5bmFtaWNfcm5uLCB3aGVyZSB0aGUgaW50ZXJtZWRpYXRlXG4gICAqIHN0YXRlIG5lZWRzIHRvIGJlIGZlZCBtYW51YWxseS5cbiAgICpcbiAgICogRm9yIGJhdGNoIGluZmVyZW5jZSBleGVjdXRpb24sIHRoZSB0ZW5zb3JzIGZvciBlYWNoIGlucHV0IG5lZWQgdG8gYmVcbiAgICogY29uY2F0ZW5hdGVkIHRvZ2V0aGVyLiBGb3IgZXhhbXBsZSB3aXRoIG1vYmlsZW5ldCwgdGhlIHJlcXVpcmVkIGlucHV0IHNoYXBlXG4gICAqIGlzIFsxLCAyNDQsIDI0NCwgM10sIHdoaWNoIHJlcHJlc2VudHMgdGhlIFtiYXRjaCwgaGVpZ2h0LCB3aWR0aCwgY2hhbm5lbF0uXG4gICAqIElmIHdlIGFyZSBwcm92aWRlIGEgYmF0Y2hlZCBkYXRhIG9mIDEwMCBpbWFnZXMsIHRoZSBpbnB1dCB0ZW5zb3Igc2hvdWxkIGJlXG4gICAqIGluIHRoZSBzaGFwZSBvZiBbMTAwLCAyNDQsIDI0NCwgM10uXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgUHJlZGljdGlvbiBjb25maWd1cmF0aW9uIGZvciBzcGVjaWZ5aW5nIHRoZSBiYXRjaCBzaXplIGFuZFxuICAgKiBvdXRwdXQgbm9kZSBuYW1lcy4gQ3VycmVudGx5IHRoZSBiYXRjaCBzaXplIG9wdGlvbiBpcyBpZ25vcmVkIGZvciBncmFwaFxuICAgKiBtb2RlbC5cbiAgICpcbiAgICogQHJldHVybnMgSW5mZXJlbmNlIHJlc3VsdCB0ZW5zb3JzLiBUaGUgb3V0cHV0IHdvdWxkIGJlIHNpbmdsZSBgdGYuVGVuc29yYFxuICAgKiBpZiBtb2RlbCBoYXMgc2luZ2xlIG91dHB1dCBub2RlLCBvdGhlcndpc2UgVGVuc29yW10gb3IgTmFtZWRUZW5zb3JNYXBbXVxuICAgKiB3aWxsIGJlIHJldHVybmVkIGZvciBtb2RlbCB3aXRoIG11bHRpcGxlIG91dHB1dHMuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBwcmVkaWN0KGlucHV0czogVGVuc29yfFRlbnNvcltdfE5hbWVkVGVuc29yTWFwLCBjb25maWc/OiBNb2RlbFByZWRpY3RDb25maWcpOlxuICAgICAgVGVuc29yfFRlbnNvcltdfE5hbWVkVGVuc29yTWFwIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKGlucHV0cywgdGhpcy5vdXRwdXROb2Rlcyk7XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZUlucHV0cyhpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXXxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTmFtZWRUZW5zb3JNYXApOiBOYW1lZFRlbnNvck1hcCB7XG4gICAgaWYgKCEoaW5wdXRzIGluc3RhbmNlb2YgVGVuc29yKSAmJiAhQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAvLyBUaGUgaW5wdXQgaXMgYWxyZWFkeSBhIE5hbWVkVGVuc29yTWFwLlxuICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgaW5wdXRzID0gQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRzIDogW2lucHV0c107XG4gICAgaWYgKGlucHV0cy5sZW5ndGggIT09IHRoaXMuaW5wdXROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSW5wdXQgdGVuc29yIGNvdW50IG1pc21hdGNoLCcgK1xuICAgICAgICAgIGB0aGUgZ3JhcGggbW9kZWwgaGFzICR7dGhpcy5pbnB1dE5vZGVzLmxlbmd0aH0gcGxhY2Vob2xkZXJzLCBgICtcbiAgICAgICAgICBgd2hpbGUgdGhlcmUgYXJlICR7aW5wdXRzLmxlbmd0aH0gaW5wdXQgdGVuc29ycy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5wdXROb2Rlcy5yZWR1Y2UoKG1hcCwgaW5wdXROYW1lLCBpKSA9PiB7XG4gICAgICBtYXBbaW5wdXROYW1lXSA9IChpbnB1dHMgYXMgVGVuc29yW10pW2ldO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCB7fSBhcyBOYW1lZFRlbnNvck1hcCk7XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZU91dHB1dHMob3V0cHV0czogc3RyaW5nfHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgIG91dHB1dHMgPSBvdXRwdXRzIHx8IHRoaXMub3V0cHV0Tm9kZXM7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KG91dHB1dHMpID8gW291dHB1dHNdIDogb3V0cHV0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBpbmZlcmVuY2UgZm9yIHRoZSBtb2RlbCBmb3IgZ2l2ZW4gaW5wdXQgdGVuc29ycy5cbiAgICogQHBhcmFtIGlucHV0cyB0ZW5zb3IsIHRlbnNvciBhcnJheSBvciB0ZW5zb3IgbWFwIG9mIHRoZSBpbnB1dHMgZm9yIHRoZVxuICAgKiBtb2RlbCwga2V5ZWQgYnkgdGhlIGlucHV0IG5vZGUgbmFtZXMuXG4gICAqIEBwYXJhbSBvdXRwdXRzIG91dHB1dCBub2RlIG5hbWUgZnJvbSB0aGUgVGVuc29yZmxvdyBtb2RlbCwgaWYgbm9cbiAgICogb3V0cHV0cyBhcmUgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBvdXRwdXRzIG9mIHRoZSBtb2RlbCB3b3VsZCBiZSB1c2VkLlxuICAgKiBZb3UgY2FuIGluc3BlY3QgaW50ZXJtZWRpYXRlIG5vZGVzIG9mIHRoZSBtb2RlbCBieSBhZGRpbmcgdGhlbSB0byB0aGVcbiAgICogb3V0cHV0cyBhcnJheS5cbiAgICpcbiAgICogQHJldHVybnMgQSBzaW5nbGUgdGVuc29yIGlmIHByb3ZpZGVkIHdpdGggYSBzaW5nbGUgb3V0cHV0IG9yIG5vIG91dHB1dHNcbiAgICogYXJlIHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBkZWZhdWx0IG91dHB1dCwgb3RoZXJ3aXNlIHJldHVybiBhXG4gICAqIHRlbnNvciBhcnJheS4gVGhlIG9yZGVyIG9mIHRoZSB0ZW5zb3IgYXJyYXkgaXMgdGhlIHNhbWUgYXMgdGhlIG91dHB1dHNcbiAgICogaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB0aGUgb3JkZXIgb2Ygb3V0cHV0Tm9kZXMgYXR0cmlidXRlIG9mIHRoZSBtb2RlbC5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGV4ZWN1dGUoaW5wdXRzOiBUZW5zb3J8VGVuc29yW118TmFtZWRUZW5zb3JNYXAsIG91dHB1dHM/OiBzdHJpbmd8c3RyaW5nW10pOlxuICAgICAgVGVuc29yfFRlbnNvcltdIHtcbiAgICBpbnB1dHMgPSB0aGlzLm5vcm1hbGl6ZUlucHV0cyhpbnB1dHMpO1xuICAgIG91dHB1dHMgPSB0aGlzLm5vcm1hbGl6ZU91dHB1dHMob3V0cHV0cyk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5leGVjdXRvci5leGVjdXRlKGlucHV0cywgb3V0cHV0cyk7XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAxID8gcmVzdWx0IDogcmVzdWx0WzBdO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBpbmZlcmVuY2UgZm9yIHRoZSBtb2RlbCBmb3IgZ2l2ZW4gaW5wdXQgdGVuc29ycyBpbiBhc3luY1xuICAgKiBmYXNoaW9uLCB1c2UgdGhpcyBtZXRob2Qgd2hlbiB5b3VyIG1vZGVsIGNvbnRhaW5zIGNvbnRyb2wgZmxvdyBvcHMuXG4gICAqIEBwYXJhbSBpbnB1dHMgdGVuc29yLCB0ZW5zb3IgYXJyYXkgb3IgdGVuc29yIG1hcCBvZiB0aGUgaW5wdXRzIGZvciB0aGVcbiAgICogbW9kZWwsIGtleWVkIGJ5IHRoZSBpbnB1dCBub2RlIG5hbWVzLlxuICAgKiBAcGFyYW0gb3V0cHV0cyBvdXRwdXQgbm9kZSBuYW1lIGZyb20gdGhlIFRlbnNvcmZsb3cgbW9kZWwsIGlmIG5vIG91dHB1dHNcbiAgICogYXJlIHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgb3V0cHV0cyBvZiB0aGUgbW9kZWwgd291bGQgYmUgdXNlZC4gWW91IGNhblxuICAgKiBpbnNwZWN0IGludGVybWVkaWF0ZSBub2RlcyBvZiB0aGUgbW9kZWwgYnkgYWRkaW5nIHRoZW0gdG8gdGhlIG91dHB1dHNcbiAgICogYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSBvZiBzaW5nbGUgdGVuc29yIGlmIHByb3ZpZGVkIHdpdGggYSBzaW5nbGUgb3V0cHV0IG9yXG4gICAqIG5vIG91dHB1dHMgYXJlIHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBkZWZhdWx0IG91dHB1dCwgb3RoZXJ3aXNlXG4gICAqIHJldHVybiBhIHRlbnNvciBtYXAuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBhc3luYyBleGVjdXRlQXN5bmMoXG4gICAgICBpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXXxOYW1lZFRlbnNvck1hcCxcbiAgICAgIG91dHB1dHM/OiBzdHJpbmd8c3RyaW5nW10pOiBQcm9taXNlPFRlbnNvcnxUZW5zb3JbXT4ge1xuICAgIGlucHV0cyA9IHRoaXMubm9ybWFsaXplSW5wdXRzKGlucHV0cyk7XG4gICAgb3V0cHV0cyA9IHRoaXMubm9ybWFsaXplT3V0cHV0cyhvdXRwdXRzKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dG9yLmV4ZWN1dGVBc3luYyhpbnB1dHMsIG91dHB1dHMpO1xuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMSA/IHJlc3VsdCA6IHJlc3VsdFswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW50ZXJtZWRpYXRlIHRlbnNvcnMgZm9yIG1vZGVsIGRlYnVnZ2luZyBtb2RlIChmbGFnXG4gICAqIEtFRVBfSU5URVJNRURJQVRFX1RFTlNPUlMgaXMgdHJ1ZSkuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBnZXRJbnRlcm1lZGlhdGVUZW5zb3JzKCk6IE5hbWVkVGVuc29yc01hcCB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0b3IuZ2V0SW50ZXJtZWRpYXRlVGVuc29ycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgaW50ZXJtZWRpYXRlIHRlbnNvcnMgZm9yIG1vZGVsIGRlYnVnZ2luZyBtb2RlIChmbGFnXG4gICAqIEtFRVBfSU5URVJNRURJQVRFX1RFTlNPUlMgaXMgdHJ1ZSkuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBkaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ycygpIHtcbiAgICB0aGlzLmV4ZWN1dG9yLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JzKCk7XG4gIH1cblxuICBwcml2YXRlIGNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAobWFwOiBOYW1lZFRlbnNvck1hcCk6IE5hbWVkVGVuc29yc01hcCB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkucmVkdWNlKChuZXdNYXA6IE5hbWVkVGVuc29yc01hcCwga2V5KSA9PiB7XG4gICAgICBuZXdNYXBba2V5XSA9IFttYXBba2V5XV07XG4gICAgICByZXR1cm4gbmV3TWFwO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgbWVtb3J5IHVzZWQgYnkgdGhlIHdlaWdodCB0ZW5zb3JzIGFuZCByZXNvdXJjZU1hbmFnZXIuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZXhlY3V0b3IuZGlzcG9zZSgpO1xuXG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYSBncmFwaCBtb2RlbCBnaXZlbiBhIFVSTCB0byB0aGUgbW9kZWwgZGVmaW5pdGlvbi5cbiAqXG4gKiBFeGFtcGxlIG9mIGxvYWRpbmcgTW9iaWxlTmV0VjIgZnJvbSBhIFVSTCBhbmQgbWFraW5nIGEgcHJlZGljdGlvbiB3aXRoIGFcbiAqIHplcm9zIGlucHV0OlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtb2RlbFVybCA9XG4gKiAgICAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3RmanMtbW9kZWxzL3NhdmVkbW9kZWwvbW9iaWxlbmV0X3YyXzEuMF8yMjQvbW9kZWwuanNvbic7XG4gKiBjb25zdCBtb2RlbCA9IGF3YWl0IHRmLmxvYWRHcmFwaE1vZGVsKG1vZGVsVXJsKTtcbiAqIGNvbnN0IHplcm9zID0gdGYuemVyb3MoWzEsIDIyNCwgMjI0LCAzXSk7XG4gKiBtb2RlbC5wcmVkaWN0KHplcm9zKS5wcmludCgpO1xuICogYGBgXG4gKlxuICogRXhhbXBsZSBvZiBsb2FkaW5nIE1vYmlsZU5ldFYyIGZyb20gYSBURiBIdWIgVVJMIGFuZCBtYWtpbmcgYSBwcmVkaWN0aW9uIHdpdGhcbiAqIGEgemVyb3MgaW5wdXQ6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1vZGVsVXJsID1cbiAqICAgICdodHRwczovL3RmaHViLmRldi9nb29nbGUvaW1hZ2VuZXQvbW9iaWxlbmV0X3YyXzE0MF8yMjQvY2xhc3NpZmljYXRpb24vMic7XG4gKiBjb25zdCBtb2RlbCA9IGF3YWl0IHRmLmxvYWRHcmFwaE1vZGVsKG1vZGVsVXJsLCB7ZnJvbVRGSHViOiB0cnVlfSk7XG4gKiBjb25zdCB6ZXJvcyA9IHRmLnplcm9zKFsxLCAyMjQsIDIyNCwgM10pO1xuICogbW9kZWwucHJlZGljdCh6ZXJvcykucHJpbnQoKTtcbiAqIGBgYFxuICogQHBhcmFtIG1vZGVsVXJsIFRoZSB1cmwgb3IgYW4gYGlvLklPSGFuZGxlcmAgdGhhdCBsb2FkcyB0aGUgbW9kZWwuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgSFRUUCByZXF1ZXN0LCB3aGljaCBhbGxvd3MgdG8gc2VuZCBjcmVkZW50aWFsc1xuICogICAgYW5kIGN1c3RvbSBoZWFkZXJzLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnTG9hZGluZyd9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkR3JhcGhNb2RlbChcbiAgICBtb2RlbFVybDogc3RyaW5nfGlvLklPSGFuZGxlcixcbiAgICBvcHRpb25zOiBpby5Mb2FkT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxHcmFwaE1vZGVsPiB7XG4gIGlmIChtb2RlbFVybCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbW9kZWxVcmwgaW4gbG9hZEdyYXBoTW9kZWwoKSBjYW5ub3QgYmUgbnVsbC4gUGxlYXNlIHByb3ZpZGUgYSB1cmwgJyArXG4gICAgICAgICdvciBhbiBJT0hhbmRsZXIgdGhhdCBsb2FkcyB0aGUgbW9kZWwnKTtcbiAgfVxuICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZnJvbVRGSHViICYmIHR5cGVvZiBtb2RlbFVybCA9PT0gJ3N0cmluZycpIHtcbiAgICBtb2RlbFVybCA9IGdldFRGSHViVXJsKG1vZGVsVXJsKTtcbiAgfVxuICBjb25zdCBtb2RlbCA9IG5ldyBHcmFwaE1vZGVsKG1vZGVsVXJsLCBvcHRpb25zKTtcbiAgYXdhaXQgbW9kZWwubG9hZCgpO1xuICByZXR1cm4gbW9kZWw7XG59XG5cbi8qKlxuICogTG9hZCBhIGdyYXBoIG1vZGVsIGdpdmVuIGEgc3luY2hyb25vdXMgSU8gaGFuZGxlciB3aXRoIGEgJ2xvYWQnIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gbW9kZWxTb3VyY2UgVGhlIGBpby5JT0hhbmRsZXJTeW5jYCB0aGF0IGxvYWRzIHRoZSBtb2RlbC5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0xvYWRpbmcnfVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkR3JhcGhNb2RlbFN5bmMoXG4gIG1vZGVsU291cmNlOiBpby5JT0hhbmRsZXJTeW5jKTogR3JhcGhNb2RlbDxpby5JT0hhbmRsZXJTeW5jPiB7XG4gIGlmIChtb2RlbFNvdXJjZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbW9kZWxVcmwgaW4gbG9hZEdyYXBoTW9kZWxTeW5jKCkgY2Fubm90IGJlIG51bGwuIFBsZWFzZSBwcm92aWRlIGEgJyArXG4gICAgICAgICd1cmwgb3IgYW4gSU9IYW5kbGVyIHRoYXQgbG9hZHMgdGhlIG1vZGVsJyk7XG4gIH1cbiAgaWYgKCFtb2RlbFNvdXJjZS5sb2FkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtb2RlbFVybCBJTyBIYW5kbGVyICR7bW9kZWxTb3VyY2V9IGhhcyBubyBsb2FkIGZ1bmN0aW9uYCk7XG4gIH1cbiAgY29uc3QgbW9kZWwgPSBuZXcgR3JhcGhNb2RlbChtb2RlbFNvdXJjZSk7XG5cbiAgbW9kZWwubG9hZCgpO1xuICByZXR1cm4gbW9kZWw7XG59XG5cbmZ1bmN0aW9uIGdldFRGSHViVXJsKG1vZGVsVXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIW1vZGVsVXJsLmVuZHNXaXRoKCcvJykpIHtcbiAgICBtb2RlbFVybCA9IChtb2RlbFVybCkgKyAnLyc7XG4gIH1cbiAgcmV0dXJuIGAke21vZGVsVXJsfSR7REVGQVVMVF9NT0RFTF9OQU1FfSR7VEZIVUJfU0VBUkNIX1BBUkFNfWA7XG59XG4iXX0=