/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
import { Im2ColPackedProgram } from '../im2col_packed_gpu';
import { mapActivationToShaderProgram } from '../kernel_utils/kernel_funcs_utils';
import { MatMulPackedProgram } from '../mulmat_packed_gpu';
import * as webgl_util from '../webgl_util';
import { batchMatMulImpl, MATMUL_SHARED_DIM_THRESHOLD } from './BatchMatMul_impl';
import { identity } from './Identity';
import { reshape } from './Reshape';
import { transpose } from './Transpose';
// For 1x1 kernels that iterate through every point in the input, convolution
// can be expressed as matrix multiplication (without need for memory
// remapping).
export function conv2dByMatMul({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the
    // result from 2D to 4D.
    const xShape = x.shape;
    const xTexData = backend.texData.get(x.dataId);
    const sharedMatMulDim = convInfo.inChannels;
    const outerShapeX = xShape[0] * xShape[1] * xShape[2];
    const outerShapeFilter = convInfo.outChannels;
    const isChannelsLast = convInfo.dataFormat === 'channelsLast';
    const transposeA = false;
    const transposeB = false;
    let out;
    const intermediates = [];
    if (preluActivationWeights != null && !isChannelsLast &&
        preluActivationWeights.shape.length === 3) {
        // If PReLU's activation weights is NCHW format, then convert it to NHWC for
        // the following computation.
        const preluActivationWeightsInNhwcFormat = transpose({
            inputs: { x: preluActivationWeights },
            backend,
            attrs: { perm: [1, 2, 0] }
        });
        intermediates.push(preluActivationWeightsInNhwcFormat);
        preluActivationWeights = preluActivationWeightsInNhwcFormat;
    }
    // TODO: Once reduction ops are packed, batchMatMul will always be packed
    // and we can remove this condition.
    const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) &&
        sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
    // The algorithm in the if condition assumes (1) the output will be packed,
    // (2) x is packed, (3) x isChannelsLast, (4)  x's packed texture is already
    // on GPU, (5) col is odd, (6) the width, height and inChannels are the same
    // for xTexData.shape and xShape.
    const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked &&
        isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 &&
        util.arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));
    if (canOptimize) {
        // We avoid expensive packed 2x2 reshape by padding col count to next,
        // even number. When col is odd, the result of packed batchMatMul is
        // the same (has the same texture layout and and values in the texture) as
        // it is for next even col. We make the odd-cols tensor to look like
        // even-cols tensor before the operation and, after the batchMatMul,
        // fix the even-cols result to have odd number of cols.
        const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);
        const xReshaped = {
            dataId: x.dataId,
            shape: [1, targetShape, convInfo.inChannels],
            dtype: x.dtype
        };
        // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.
        // Decrementing col count, after batchMatMul->...->compileProgram leads to
        // invalid col count within the reference in GPGPUBinary.inShapeInfos.
        // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos
        // in compileProgram method, but that would affect compilation of all
        // programs - instead, provide a copy here, with even col count, before
        // calling batchMatMul->...->compileProgram and after that, the original
        // xTexData.shape is restored.
        const originalXTexDataShape = xTexData.shape;
        xTexData.shape = xTexData.shape.slice();
        xTexData.shape[xTexData.shape.length - 2]++;
        util.assert(webgl_util.isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
        const filterReshaped = reshape({
            inputs: { x: filter },
            backend,
            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
        });
        intermediates.push(filterReshaped);
        const pointwiseConv = batchMatMulImpl({
            a: xReshaped,
            b: filterReshaped,
            backend,
            transposeA,
            transposeB,
            bias,
            activation,
            preluActivationWeights,
            leakyreluAlpha
        });
        const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);
        util.assert(pointwiseConvTexData.isPacked, () => 'batchMatMul result is expected to be packed');
        // Restore the input shape to original.
        xTexData.shape = originalXTexDataShape;
        // Set the output shape - there is no need for expensive reshape as data
        // layout is already correct.
        pointwiseConvTexData.shape = convInfo.outShape;
        out = identity({ inputs: { x: pointwiseConv }, backend });
        out.shape = convInfo.outShape;
        intermediates.push(pointwiseConv);
    }
    else {
        const xInNhwcFormat = isChannelsLast ?
            x :
            transpose({ inputs: { x }, backend, attrs: { perm: [0, 2, 3, 1] } });
        const xInNhwcFormatShape = xInNhwcFormat.shape;
        const targetShape = xInNhwcFormatShape[0] * xInNhwcFormatShape[1] * xInNhwcFormatShape[2];
        const xReshaped = reshape({
            inputs: { x: xInNhwcFormat },
            backend,
            attrs: { shape: [1, targetShape, convInfo.inChannels] }
        });
        const filterReshaped = reshape({
            inputs: { x: filter },
            backend,
            attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
        });
        const result = batchMatMulImpl({
            a: xReshaped,
            b: filterReshaped,
            transposeA,
            transposeB,
            backend,
            bias,
            activation,
            preluActivationWeights,
            leakyreluAlpha
        });
        const outInNHWCFormatShape = [
            convInfo.batchSize, convInfo.outHeight, convInfo.outWidth,
            convInfo.outChannels
        ];
        const outInNHWCFormat = reshape({ inputs: { x: result }, backend, attrs: { shape: outInNHWCFormatShape } });
        // If the data format is NCHW, then convert the output to be NCHW format.
        out = isChannelsLast ? outInNHWCFormat : transpose({
            inputs: { x: outInNHWCFormat },
            backend,
            attrs: { perm: [0, 3, 1, 2] }
        });
        if (!isChannelsLast) {
            intermediates.push(xInNhwcFormat);
            intermediates.push(outInNHWCFormat);
        }
        intermediates.push(xReshaped);
        intermediates.push(filterReshaped);
        intermediates.push(result);
    }
    for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
    }
    return out;
}
// Implements the im2row algorithm as outlined in "High Performance
// Convolutional Neural Networks for Document Processing" (Suvisoft, 2006)
export function conv2dWithIm2Row({ x, filter, convInfo, backend, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    // Rearranges conv2d input so each block to be convolved over forms the
    // column of a new matrix with shape [filterWidth * filterHeight *
    // inChannels, outHeight * outWidth]. The filter is also rearranged so each
    // output channel forms a row of a new matrix with shape [outChannels,
    // filterWidth * filterHeight * inChannels]. The convolution is then
    // computed by multiplying these matrices and reshaping the result.
    const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
    const isChannelsLast = dataFormat === 'channelsLast';
    const sharedDim = filterWidth * filterHeight * inChannels;
    const numCols = outHeight * outWidth;
    const x2ColShape = [sharedDim, numCols];
    const transposeA = true;
    const transposeB = false;
    const intermediates = [];
    if (preluActivationWeights != null && !isChannelsLast &&
        preluActivationWeights.shape.length === 3) {
        // If PReLU's activation weights is NCHW format, then convert it to NHWC for
        // the following computation.
        const preluActivationWeightsInNhwcFormat = transpose({
            inputs: { x: preluActivationWeights },
            backend,
            attrs: { perm: [1, 2, 0] }
        });
        intermediates.push(preluActivationWeightsInNhwcFormat);
        preluActivationWeights = preluActivationWeightsInNhwcFormat;
    }
    const xSqueezed = reshape({ inputs: { x }, backend, attrs: { shape: x.shape.slice(1) } });
    const w2Row = reshape({
        inputs: { x: filter },
        backend,
        attrs: { shape: [1, sharedDim, util.sizeFromShape(filter.shape) / sharedDim] }
    });
    intermediates.push(xSqueezed);
    intermediates.push(w2Row);
    const im2ColProgram = new Im2ColPackedProgram(x2ColShape, convInfo);
    const customValues = [
        xSqueezed.shape, [convInfo.padInfo.top, convInfo.padInfo.left],
        [convInfo.strideHeight, convInfo.strideWidth],
        [convInfo.dilationHeight, convInfo.dilationWidth], [convInfo.inChannels],
        [convInfo.filterWidth * convInfo.inChannels], [convInfo.outWidth]
    ];
    const im2Col = backend.runWebGLProgram(im2ColProgram, [xSqueezed], 'float32', customValues);
    const im2ColReshaped = reshape({
        inputs: { x: im2Col },
        backend,
        attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }
    });
    intermediates.push(im2Col);
    intermediates.push(im2ColReshaped);
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;
    const matmulProgram = new MatMulPackedProgram(im2ColReshaped.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = [im2ColReshaped, w2Row];
    if (bias) {
        inputs.push(bias);
    }
    if (hasPreluActivationWeights) {
        inputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', util.createScalarValue(leakyreluAlpha, 'float32'));
        inputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
    }
    const product = backend.runWebGLProgram(matmulProgram, inputs, 'float32');
    const outInNHWCFormatShape = [1, outHeight, outWidth, convInfo.outChannels];
    const outInNHWCFormat = reshape({ inputs: { x: product }, backend, attrs: { shape: outInNHWCFormatShape } });
    // If the data format is NCHW, then convert the output to be NCHW format.
    const out = isChannelsLast ?
        outInNHWCFormat :
        transpose({ inputs: { x: outInNHWCFormat }, backend, attrs: { perm: [0, 3, 1, 2] } });
    if (!isChannelsLast) {
        intermediates.push(outInNHWCFormat);
    }
    intermediates.push(product);
    for (const i of intermediates) {
        backend.disposeIntermediateTensorInfo(i);
    }
    return out;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udjJEX2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL2tlcm5lbHMvQ29udjJEX2ltcGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUEyQixJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUtyRSxPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUN6RCxPQUFPLEVBQUMsNEJBQTRCLEVBQUMsTUFBTSxvQ0FBb0MsQ0FBQztBQUNoRixPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUN6RCxPQUFPLEtBQUssVUFBVSxNQUFNLGVBQWUsQ0FBQztBQUU1QyxPQUFPLEVBQUMsZUFBZSxFQUFFLDJCQUEyQixFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDaEYsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNwQyxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2xDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFhdEMsNkVBQTZFO0FBQzdFLHFFQUFxRTtBQUNyRSxjQUFjO0FBQ2QsTUFBTSxVQUFVLGNBQWMsQ0FBQyxFQUM3QixDQUFDLEVBQ0QsTUFBTSxFQUNOLFFBQVEsRUFDUixPQUFPLEVBQ1AsSUFBSSxHQUFHLElBQUksRUFDWCxzQkFBc0IsR0FBRyxJQUFJLEVBQzdCLGNBQWMsR0FBRyxDQUFDLEVBQ2xCLFVBQVUsR0FBRyxJQUFJLEVBQ0o7SUFDYix3RUFBd0U7SUFDeEUsd0JBQXdCO0lBQ3hCLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDdkIsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxD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RUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUMsRUFBQyxDQUFDLENBQUM7SUFDOUUsSUFBSSxDQUFDLGNBQWMsRUFBRTtRQUNuQixhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ3JDO0lBRUQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1QixLQUFLLE1BQU0sQ0FBQyxJQUFJLGFBQWEsRUFBRTtRQUM3QixPQUFPLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDMUM7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBUZW5zb3JJbmZvLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG4vLyBpbXBvcnQge2Fzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlfSBmcm9tXG4vLyAnLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvYnJvYWRjYXN0X3V0aWwnO1xuaW1wb3J0IHtNYXRoQmFja2VuZFdlYkdMfSBmcm9tICcuLi9iYWNrZW5kX3dlYmdsJztcbmltcG9ydCB7SW0yQ29sUGFja2VkUHJvZ3JhbX0gZnJvbSAnLi4vaW0yY29sX3BhY2tlZF9ncHUnO1xuaW1wb3J0IHttYXBBY3RpdmF0aW9uVG9TaGFkZXJQcm9ncmFtfSBmcm9tICcuLi9rZXJuZWxfdXRpbHMva2VybmVsX2Z1bmNzX3V0aWxzJztcbmltcG9ydCB7TWF0TXVsUGFja2VkUHJvZ3JhbX0gZnJvbSAnLi4vbXVsbWF0X3BhY2tlZF9ncHUnO1xuaW1wb3J0ICogYXMgd2ViZ2xfdXRpbCBmcm9tICcuLi93ZWJnbF91dGlsJztcblxuaW1wb3J0IHtiYXRjaE1hdE11bEltcGwsIE1BVE1VTF9TSEFSRURfRElNX1RIUkVTSE9MRH0gZnJvbSAnLi9CYXRjaE1hdE11bF9pbXBsJztcbmltcG9ydCB7aWRlbnRpdHl9IGZyb20gJy4vSWRlbnRpdHknO1xuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuL1Jlc2hhcGUnO1xuaW1wb3J0IHt0cmFuc3Bvc2V9IGZyb20gJy4vVHJhbnNwb3NlJztcblxudHlwZSBDb252MkRDb25maWcgPSB7XG4gIHg6IFRlbnNvckluZm8sXG4gIGZpbHRlcjogVGVuc29ySW5mbyxcbiAgY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252MkRJbmZvLFxuICBiYWNrZW5kOiBNYXRoQmFja2VuZFdlYkdMLFxuICBiaWFzPzogVGVuc29ySW5mbyxcbiAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cz86IFRlbnNvckluZm8sXG4gIGxlYWt5cmVsdUFscGhhPzogbnVtYmVyLFxuICBhY3RpdmF0aW9uPzogYmFja2VuZF91dGlsLkFjdGl2YXRpb25cbn07XG5cbi8vIEZvciAxeDEga2VybmVscyB0aGF0IGl0ZXJhdGUgdGhyb3VnaCBldmVyeSBwb2ludCBpbiB0aGUgaW5wdXQsIGNvbnZvbHV0aW9uXG4vLyBjYW4gYmUgZXhwcmVzc2VkIGFzIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiAod2l0aG91dCBuZWVkIGZvciBtZW1vcnlcbi8vIHJlbWFwcGluZykuXG5leHBvcnQgZnVuY3Rpb24gY29udjJkQnlNYXRNdWwoe1xuICB4LFxuICBmaWx0ZXIsXG4gIGNvbnZJbmZvLFxuICBiYWNrZW5kLFxuICBiaWFzID0gbnVsbCxcbiAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IG51bGwsXG4gIGxlYWt5cmVsdUFscGhhID0gMCxcbiAgYWN0aXZhdGlvbiA9IG51bGxcbn06IENvbnYyRENvbmZpZykge1xuICAvLyBSZXNoYXBlcyBjb252MkQgaW5wdXQgdG8gMkQgdGVuc29ycywgdXNlcyBtYXRNdWwgYW5kIHRoZW4gcmVzaGFwZSB0aGVcbiAgLy8gcmVzdWx0IGZyb20gMkQgdG8gNEQuXG4gIGNvbnN0IHhTaGFwZSA9IHguc2hhcGU7XG4gIGNvbnN0IHhUZXhEYXRhID0gYmFja2VuZC50ZXhEYXRhLmdldCh4LmRhdGFJZCk7XG4gIGNvbnN0IHNoYXJlZE1hdE11bERpbSA9IGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gIGNvbnN0IG91dGVyU2hhcGVYID0geFNoYXBlWzBdICogeFNoYXBlWzFdICogeFNoYXBlWzJdO1xuICBjb25zdCBvdXRlclNoYXBlRmlsdGVyID0gY29udkluZm8ub3V0Q2hhbm5lbHM7XG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gIGNvbnN0IHRyYW5zcG9zZUEgPSBmYWxzZTtcbiAgY29uc3QgdHJhbnNwb3NlQiA9IGZhbHNlO1xuXG4gIGxldCBvdXQ6IFRlbnNvckluZm87XG4gIGNvbnN0IGludGVybWVkaWF0ZXM6IFRlbnNvckluZm9bXSA9IFtdO1xuXG4gIGlmIChwcmVsdUFjdGl2YXRpb25XZWlnaHRzICE9IG51bGwgJiYgIWlzQ2hhbm5lbHNMYXN0ICYmXG4gICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLnNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIC8vIElmIFBSZUxVJ3MgYWN0aXZhdGlvbiB3ZWlnaHRzIGlzIE5DSFcgZm9ybWF0LCB0aGVuIGNvbnZlcnQgaXQgdG8gTkhXQyBmb3JcbiAgICAvLyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uLlxuICAgIGNvbnN0IHByZWx1QWN0aXZhdGlvbldlaWdodHNJbk5od2NGb3JtYXQgPSB0cmFuc3Bvc2Uoe1xuICAgICAgaW5wdXRzOiB7eDogcHJlbHVBY3RpdmF0aW9uV2VpZ2h0c30sXG4gICAgICBiYWNrZW5kLFxuICAgICAgYXR0cnM6IHtwZXJtOiBbMSwgMiwgMF19XG4gICAgfSk7XG4gICAgaW50ZXJtZWRpYXRlcy5wdXNoKHByZWx1QWN0aXZhdGlvbldlaWdodHNJbk5od2NGb3JtYXQpO1xuICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBwcmVsdUFjdGl2YXRpb25XZWlnaHRzSW5OaHdjRm9ybWF0O1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSByZWR1Y3Rpb24gb3BzIGFyZSBwYWNrZWQsIGJhdGNoTWF0TXVsIHdpbGwgYWx3YXlzIGJlIHBhY2tlZFxuICAvLyBhbmQgd2UgY2FuIHJlbW92ZSB0aGlzIGNvbmRpdGlvbi5cbiAgY29uc3QgYmF0Y2hNYXRNdWxXaWxsQmVVbnBhY2tlZCA9XG4gICAgICAob3V0ZXJTaGFwZVggPT09IDEgfHwgb3V0ZXJTaGFwZUZpbHRlciA9PT0gMSkgJiZcbiAgICAgIHNoYXJlZE1hdE11bERpbSA+IE1BVE1VTF9TSEFSRURfRElNX1RIUkVTSE9MRDtcblxuICAvLyBUaGUgYWxnb3JpdGhtIGluIHRoZSBpZiBjb25kaXRpb24gYXNzdW1lcyAoMSkgdGhlIG91dHB1dCB3aWxsIGJlIHBhY2tlZCxcbiAgLy8gKDIpIHggaXMgcGFja2VkLCAoMykgeCBpc0NoYW5uZWxzTGFzdCwgKDQpICB4J3MgcGFja2VkIHRleHR1cmUgaXMgYWxyZWFkeVxuICAvLyBvbiBHUFUsICg1KSBjb2wgaXMgb2RkLCAoNikgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIGluQ2hhbm5lbHMgYXJlIHRoZSBzYW1lXG4gIC8vIGZvciB4VGV4RGF0YS5zaGFwZSBhbmQgeFNoYXBlLlxuICBjb25zdCBjYW5PcHRpbWl6ZSA9ICFiYXRjaE1hdE11bFdpbGxCZVVucGFja2VkICYmIHhUZXhEYXRhLmlzUGFja2VkICYmXG4gICAgICBpc0NoYW5uZWxzTGFzdCAmJiB4VGV4RGF0YS50ZXh0dXJlICE9IG51bGwgJiYgeFNoYXBlWzJdICUgMiAhPT0gMCAmJlxuICAgICAgdXRpbC5hcnJheXNFcXVhbCh4VGV4RGF0YS5zaGFwZS5zbGljZSgtMyksIHhTaGFwZS5zbGljZSgtMykpO1xuXG4gIGlmIChjYW5PcHRpbWl6ZSkge1xuICAgIC8vIFdlIGF2b2lkIGV4cGVuc2l2ZSBwYWNrZWQgMngyIHJlc2hhcGUgYnkgcGFkZGluZyBjb2wgY291bnQgdG8gbmV4dCxcbiAgICAvLyBldmVuIG51bWJlci4gV2hlbiBjb2wgaXMgb2RkLCB0aGUgcmVzdWx0IG9mIHBhY2tlZCBiYXRjaE1hdE11bCBpc1xuICAgIC8vIHRoZSBzYW1lIChoYXMgdGhlIHNhbWUgdGV4dHVyZSBsYXlvdXQgYW5kIGFuZCB2YWx1ZXMgaW4gdGhlIHRleHR1cmUpIGFzXG4gICAgLy8gaXQgaXMgZm9yIG5leHQgZXZlbiBjb2wuIFdlIG1ha2UgdGhlIG9kZC1jb2xzIHRlbnNvciB0byBsb29rIGxpa2VcbiAgICAvLyBldmVuLWNvbHMgdGVuc29yIGJlZm9yZSB0aGUgb3BlcmF0aW9uIGFuZCwgYWZ0ZXIgdGhlIGJhdGNoTWF0TXVsLFxuICAgIC8vIGZpeCB0aGUgZXZlbi1jb2xzIHJlc3VsdCB0byBoYXZlIG9kZCBudW1iZXIgb2YgY29scy5cbiAgICBjb25zdCB0YXJnZXRTaGFwZSA9IHhTaGFwZVswXSAqIHhTaGFwZVsxXSAqICh4U2hhcGVbMl0gKyAxKTtcbiAgICBjb25zdCB4UmVzaGFwZWQ6IFRlbnNvckluZm8gPSB7XG4gICAgICBkYXRhSWQ6IHguZGF0YUlkLFxuICAgICAgc2hhcGU6IFsxLCB0YXJnZXRTaGFwZSwgY29udkluZm8uaW5DaGFubmVsc10sXG4gICAgICBkdHlwZTogeC5kdHlwZVxuICAgIH07XG4gICAgLy8geFRleERhdGEuc2hhcGUgZ2V0cyByZWZlcmVuY2VkIGZyb20gR1BHUFVCaW5hcnkuaW5TaGFwZUluZm9zLlxuICAgIC8vIERlY3JlbWVudGluZyBjb2wgY291bnQsIGFmdGVyIGJhdGNoTWF0TXVsLT4uLi4tPmNvbXBpbGVQcm9ncmFtIGxlYWRzIHRvXG4gICAgLy8gaW52YWxpZCBjb2wgY291bnQgd2l0aGluIHRoZSByZWZlcmVuY2UgaW4gR1BHUFVCaW5hcnkuaW5TaGFwZUluZm9zLlxuICAgIC8vIEFsdGVybmF0aXZlIGZpeCB3b3VsZCBiZSB0byBwcm92aWRlIGEgY29weSB0byBHUEdQVUJpbmFyeS5pblNoYXBlSW5mb3NcbiAgICAvLyBpbiBjb21waWxlUHJvZ3JhbSBtZXRob2QsIGJ1dCB0aGF0IHdvdWxkIGFmZmVjdCBjb21waWxhdGlvbiBvZiBhbGxcbiAgICAvLyBwcm9ncmFtcyAtIGluc3RlYWQsIHByb3ZpZGUgYSBjb3B5IGhlcmUsIHdpdGggZXZlbiBjb2wgY291bnQsIGJlZm9yZVxuICAgIC8vIGNhbGxpbmcgYmF0Y2hNYXRNdWwtPi4uLi0+Y29tcGlsZVByb2dyYW0gYW5kIGFmdGVyIHRoYXQsIHRoZSBvcmlnaW5hbFxuICAgIC8vIHhUZXhEYXRhLnNoYXBlIGlzIHJlc3RvcmVkLlxuICAgIGNvbnN0IG9yaWdpbmFsWFRleERhdGFTaGFwZSA9IHhUZXhEYXRhLnNoYXBlO1xuICAgIHhUZXhEYXRhLnNoYXBlID0geFRleERhdGEuc2hhcGUuc2xpY2UoKTtcbiAgICB4VGV4RGF0YS5zaGFwZVt4VGV4RGF0YS5zaGFwZS5sZW5ndGggLSAyXSsrO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB3ZWJnbF91dGlsLmlzUmVzaGFwZUZyZWUoeFRleERhdGEuc2hhcGUsIHhSZXNoYXBlZC5zaGFwZSksXG4gICAgICAgICgpID0+IGBwYWNrZWQgcmVzaGFwZSAke3hUZXhEYXRhLnNoYXBlfSB0byAke1xuICAgICAgICAgICAgeFJlc2hhcGVkLnNoYXBlfSBpc24ndCBmcmVlYCk7XG4gICAgY29uc3QgZmlsdGVyUmVzaGFwZWQgPSByZXNoYXBlKHtcbiAgICAgIGlucHV0czoge3g6IGZpbHRlcn0sXG4gICAgICBiYWNrZW5kLFxuICAgICAgYXR0cnM6IHtzaGFwZTogWzEsIGNvbnZJbmZvLmluQ2hhbm5lbHMsIGNvbnZJbmZvLm91dENoYW5uZWxzXX1cbiAgICB9KTtcbiAgICBpbnRlcm1lZGlhdGVzLnB1c2goZmlsdGVyUmVzaGFwZWQpO1xuICAgIGNvbnN0IHBvaW50d2lzZUNvbnYgPSBiYXRjaE1hdE11bEltcGwoe1xuICAgICAgYTogeFJlc2hhcGVkLFxuICAgICAgYjogZmlsdGVyUmVzaGFwZWQsXG4gICAgICBiYWNrZW5kLFxuICAgICAgdHJhbnNwb3NlQSxcbiAgICAgIHRyYW5zcG9zZUIsXG4gICAgICBiaWFzLFxuICAgICAgYWN0aXZhdGlvbixcbiAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHMsXG4gICAgICBsZWFreXJlbHVBbHBoYVxuICAgIH0pO1xuXG4gICAgY29uc3QgcG9pbnR3aXNlQ29udlRleERhdGEgPSBiYWNrZW5kLnRleERhdGEuZ2V0KHBvaW50d2lzZUNvbnYuZGF0YUlkKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgcG9pbnR3aXNlQ29udlRleERhdGEuaXNQYWNrZWQsXG4gICAgICAgICgpID0+ICdiYXRjaE1hdE11bCByZXN1bHQgaXMgZXhwZWN0ZWQgdG8gYmUgcGFja2VkJyk7XG4gICAgLy8gUmVzdG9yZSB0aGUgaW5wdXQgc2hhcGUgdG8gb3JpZ2luYWwuXG4gICAgeFRleERhdGEuc2hhcGUgPSBvcmlnaW5hbFhUZXhEYXRhU2hhcGU7XG4gICAgLy8gU2V0IHRoZSBvdXRwdXQgc2hhcGUgLSB0aGVyZSBpcyBubyBuZWVkIGZvciBleHBlbnNpdmUgcmVzaGFwZSBhcyBkYXRhXG4gICAgLy8gbGF5b3V0IGlzIGFscmVhZHkgY29ycmVjdC5cbiAgICBwb2ludHdpc2VDb252VGV4RGF0YS5zaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuXG4gICAgb3V0ID0gaWRlbnRpdHkoe2lucHV0czoge3g6IHBvaW50d2lzZUNvbnZ9LCBiYWNrZW5kfSk7XG4gICAgb3V0LnNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG5cbiAgICBpbnRlcm1lZGlhdGVzLnB1c2gocG9pbnR3aXNlQ29udik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeEluTmh3Y0Zvcm1hdCA9IGlzQ2hhbm5lbHNMYXN0ID9cbiAgICAgICAgeCA6XG4gICAgICAgIHRyYW5zcG9zZSh7aW5wdXRzOiB7eH0sIGJhY2tlbmQsIGF0dHJzOiB7cGVybTogWzAsIDIsIDMsIDFdfX0pO1xuICAgIGNvbnN0IHhJbk5od2NGb3JtYXRTaGFwZSA9IHhJbk5od2NGb3JtYXQuc2hhcGU7XG4gICAgY29uc3QgdGFyZ2V0U2hhcGUgPVxuICAgICAgICB4SW5OaHdjRm9ybWF0U2hhcGVbMF0gKiB4SW5OaHdjRm9ybWF0U2hhcGVbMV0gKiB4SW5OaHdjRm9ybWF0U2hhcGVbMl07XG4gICAgY29uc3QgeFJlc2hhcGVkID0gcmVzaGFwZSh7XG4gICAgICBpbnB1dHM6IHt4OiB4SW5OaHdjRm9ybWF0fSxcbiAgICAgIGJhY2tlbmQsXG4gICAgICBhdHRyczoge3NoYXBlOiBbMSwgdGFyZ2V0U2hhcGUsIGNvbnZJbmZvLmluQ2hhbm5lbHNdfVxuICAgIH0pO1xuICAgIGNvbnN0IGZpbHRlclJlc2hhcGVkID0gcmVzaGFwZSh7XG4gICAgICBpbnB1dHM6IHt4OiBmaWx0ZXJ9LFxuICAgICAgYmFja2VuZCxcbiAgICAgIGF0dHJzOiB7c2hhcGU6IFsxLCBjb252SW5mby5pbkNoYW5uZWxzLCBjb252SW5mby5vdXRDaGFubmVsc119XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYmF0Y2hNYXRNdWxJbXBsKHtcbiAgICAgIGE6IHhSZXNoYXBlZCxcbiAgICAgIGI6IGZpbHRlclJlc2hhcGVkLFxuICAgICAgdHJhbnNwb3NlQSxcbiAgICAgIHRyYW5zcG9zZUIsXG4gICAgICBiYWNrZW5kLFxuICAgICAgYmlhcyxcbiAgICAgIGFjdGl2YXRpb24sXG4gICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLFxuICAgICAgbGVha3lyZWx1QWxwaGFcbiAgICB9KTtcblxuICAgIGNvbnN0IG91dEluTkhXQ0Zvcm1hdFNoYXBlID0gW1xuICAgICAgY29udkluZm8uYmF0Y2hTaXplLCBjb252SW5mby5vdXRIZWlnaHQsIGNvbnZJbmZvLm91dFdpZHRoLFxuICAgICAgY29udkluZm8ub3V0Q2hhbm5lbHNcbiAgICBdO1xuICAgIGNvbnN0IG91dEluTkhXQ0Zvcm1hdCA9IHJlc2hhcGUoXG4gICAgICAgIHtpbnB1dHM6IHt4OiByZXN1bHR9LCBiYWNrZW5kLCBhdHRyczoge3NoYXBlOiBvdXRJbk5IV0NGb3JtYXRTaGFwZX19KTtcblxuICAgIC8vIElmIHRoZSBkYXRhIGZvcm1hdCBpcyBOQ0hXLCB0aGVuIGNvbnZlcnQgdGhlIG91dHB1dCB0byBiZSBOQ0hXIGZvcm1hdC5cbiAgICBvdXQgPSBpc0NoYW5uZWxzTGFzdCA/IG91dEluTkhXQ0Zvcm1hdCA6IHRyYW5zcG9zZSh7XG4gICAgICBpbnB1dHM6IHt4OiBvdXRJbk5IV0NGb3JtYXR9LFxuICAgICAgYmFja2VuZCxcbiAgICAgIGF0dHJzOiB7cGVybTogWzAsIDMsIDEsIDJdfVxuICAgIH0pO1xuICAgIGlmICghaXNDaGFubmVsc0xhc3QpIHtcbiAgICAgIGludGVybWVkaWF0ZXMucHVzaCh4SW5OaHdjRm9ybWF0KTtcbiAgICAgIGludGVybWVkaWF0ZXMucHVzaChvdXRJbk5IV0NGb3JtYXQpO1xuICAgIH1cblxuICAgIGludGVybWVkaWF0ZXMucHVzaCh4UmVzaGFwZWQpO1xuICAgIGludGVybWVkaWF0ZXMucHVzaChmaWx0ZXJSZXNoYXBlZCk7XG4gICAgaW50ZXJtZWRpYXRlcy5wdXNoKHJlc3VsdCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJtZWRpYXRlcykge1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBJbXBsZW1lbnRzIHRoZSBpbTJyb3cgYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluIFwiSGlnaCBQZXJmb3JtYW5jZVxuLy8gQ29udm9sdXRpb25hbCBOZXVyYWwgTmV0d29ya3MgZm9yIERvY3VtZW50IFByb2Nlc3NpbmdcIiAoU3V2aXNvZnQsIDIwMDYpXG5leHBvcnQgZnVuY3Rpb24gY29udjJkV2l0aEltMlJvdyh7XG4gIHgsXG4gIGZpbHRlcixcbiAgY29udkluZm8sXG4gIGJhY2tlbmQsXG4gIGJpYXMgPSBudWxsLFxuICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gbnVsbCxcbiAgbGVha3lyZWx1QWxwaGEgPSAwLFxuICBhY3RpdmF0aW9uID0gbnVsbFxufTogQ29udjJEQ29uZmlnKSB7XG4gIC8vIFJlYXJyYW5nZXMgY29udjJkIGlucHV0IHNvIGVhY2ggYmxvY2sgdG8gYmUgY29udm9sdmVkIG92ZXIgZm9ybXMgdGhlXG4gIC8vIGNvbHVtbiBvZiBhIG5ldyBtYXRyaXggd2l0aCBzaGFwZSBbZmlsdGVyV2lkdGggKiBmaWx0ZXJIZWlnaHQgKlxuICAvLyBpbkNoYW5uZWxzLCBvdXRIZWlnaHQgKiBvdXRXaWR0aF0uIFRoZSBmaWx0ZXIgaXMgYWxzbyByZWFycmFuZ2VkIHNvIGVhY2hcbiAgLy8gb3V0cHV0IGNoYW5uZWwgZm9ybXMgYSByb3cgb2YgYSBuZXcgbWF0cml4IHdpdGggc2hhcGUgW291dENoYW5uZWxzLFxuICAvLyBmaWx0ZXJXaWR0aCAqIGZpbHRlckhlaWdodCAqIGluQ2hhbm5lbHNdLiBUaGUgY29udm9sdXRpb24gaXMgdGhlblxuICAvLyBjb21wdXRlZCBieSBtdWx0aXBseWluZyB0aGVzZSBtYXRyaWNlcyBhbmQgcmVzaGFwaW5nIHRoZSByZXN1bHQuXG4gIGNvbnN0IHtcbiAgICBmaWx0ZXJXaWR0aCxcbiAgICBmaWx0ZXJIZWlnaHQsXG4gICAgaW5DaGFubmVscyxcbiAgICBvdXRXaWR0aCxcbiAgICBvdXRIZWlnaHQsXG4gICAgZGF0YUZvcm1hdFxuICB9ID0gY29udkluZm87XG5cbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0JztcblxuICBjb25zdCBzaGFyZWREaW0gPSBmaWx0ZXJXaWR0aCAqIGZpbHRlckhlaWdodCAqIGluQ2hhbm5lbHM7XG4gIGNvbnN0IG51bUNvbHMgPSBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcbiAgY29uc3QgeDJDb2xTaGFwZSA9IFtzaGFyZWREaW0sIG51bUNvbHNdO1xuICBjb25zdCB0cmFuc3Bvc2VBID0gdHJ1ZTtcbiAgY29uc3QgdHJhbnNwb3NlQiA9IGZhbHNlO1xuXG4gIGNvbnN0IGludGVybWVkaWF0ZXM6IFRlbnNvckluZm9bXSA9IFtdO1xuXG4gIGlmIChwcmVsdUFjdGl2YXRpb25XZWlnaHRzICE9IG51bGwgJiYgIWlzQ2hhbm5lbHNMYXN0ICYmXG4gICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLnNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIC8vIElmIFBSZUxVJ3MgYWN0aXZhdGlvbiB3ZWlnaHRzIGlzIE5DSFcgZm9ybWF0LCB0aGVuIGNvbnZlcnQgaXQgdG8gTkhXQyBmb3JcbiAgICAvLyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uLlxuICAgIGNvbnN0IHByZWx1QWN0aXZhdGlvbldlaWdodHNJbk5od2NGb3JtYXQgPSB0cmFuc3Bvc2Uoe1xuICAgICAgaW5wdXRzOiB7eDogcHJlbHVBY3RpdmF0aW9uV2VpZ2h0c30sXG4gICAgICBiYWNrZW5kLFxuICAgICAgYXR0cnM6IHtwZXJtOiBbMSwgMiwgMF19XG4gICAgfSk7XG4gICAgaW50ZXJtZWRpYXRlcy5wdXNoKHByZWx1QWN0aXZhdGlvbldlaWdodHNJbk5od2NGb3JtYXQpO1xuICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBwcmVsdUFjdGl2YXRpb25XZWlnaHRzSW5OaHdjRm9ybWF0O1xuICB9XG5cbiAgY29uc3QgeFNxdWVlemVkID1cbiAgICAgIHJlc2hhcGUoe2lucHV0czoge3h9LCBiYWNrZW5kLCBhdHRyczoge3NoYXBlOiB4LnNoYXBlLnNsaWNlKDEpfX0pO1xuICBjb25zdCB3MlJvdyA9IHJlc2hhcGUoe1xuICAgIGlucHV0czoge3g6IGZpbHRlcn0sXG4gICAgYmFja2VuZCxcbiAgICBhdHRyczoge3NoYXBlOiBbMSwgc2hhcmVkRGltLCB1dGlsLnNpemVGcm9tU2hhcGUoZmlsdGVyLnNoYXBlKSAvIHNoYXJlZERpbV19XG4gIH0pO1xuXG4gIGludGVybWVkaWF0ZXMucHVzaCh4U3F1ZWV6ZWQpO1xuICBpbnRlcm1lZGlhdGVzLnB1c2godzJSb3cpO1xuXG4gIGNvbnN0IGltMkNvbFByb2dyYW0gPSBuZXcgSW0yQ29sUGFja2VkUHJvZ3JhbSh4MkNvbFNoYXBlLCBjb252SW5mbyk7XG4gIGNvbnN0IGN1c3RvbVZhbHVlcyA9IFtcbiAgICB4U3F1ZWV6ZWQuc2hhcGUsIFtjb252SW5mby5wYWRJbmZvLnRvcCwgY29udkluZm8ucGFkSW5mby5sZWZ0XSxcbiAgICBbY29udkluZm8uc3RyaWRlSGVpZ2h0LCBjb252SW5mby5zdHJpZGVXaWR0aF0sXG4gICAgW2NvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0LCBjb252SW5mby5kaWxhdGlvbldpZHRoXSwgW2NvbnZJbmZvLmluQ2hhbm5lbHNdLFxuICAgIFtjb252SW5mby5maWx0ZXJXaWR0aCAqIGNvbnZJbmZvLmluQ2hhbm5lbHNdLCBbY29udkluZm8ub3V0V2lkdGhdXG4gIF07XG4gIGNvbnN0IGltMkNvbCA9IGJhY2tlbmQucnVuV2ViR0xQcm9ncmFtKFxuICAgICAgaW0yQ29sUHJvZ3JhbSwgW3hTcXVlZXplZF0sICdmbG9hdDMyJywgY3VzdG9tVmFsdWVzKTtcbiAgY29uc3QgaW0yQ29sUmVzaGFwZWQgPSByZXNoYXBlKHtcbiAgICBpbnB1dHM6IHt4OiBpbTJDb2x9LFxuICAgIGJhY2tlbmQsXG4gICAgYXR0cnM6IHtzaGFwZTogWzEsIHgyQ29sU2hhcGVbMF0sIHgyQ29sU2hhcGVbMV1dfVxuICB9KTtcblxuICBpbnRlcm1lZGlhdGVzLnB1c2goaW0yQ29sKTtcbiAgaW50ZXJtZWRpYXRlcy5wdXNoKGltMkNvbFJlc2hhcGVkKTtcblxuICBjb25zdCBoYXNCaWFzID0gYmlhcyAhPSBudWxsO1xuICBjb25zdCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsO1xuICBjb25zdCBoYXNMZWFreXJlbHVBbHBoYSA9IGFjdGl2YXRpb24gPT09ICdsZWFreXJlbHUnO1xuICBjb25zdCBmdXNlZEFjdGl2YXRpb24gPVxuICAgICAgYWN0aXZhdGlvbiA/IG1hcEFjdGl2YXRpb25Ub1NoYWRlclByb2dyYW0oYWN0aXZhdGlvbiwgdHJ1ZSkgOiBudWxsO1xuICBjb25zdCBtYXRtdWxQcm9ncmFtID0gbmV3IE1hdE11bFBhY2tlZFByb2dyYW0oXG4gICAgICBpbTJDb2xSZXNoYXBlZC5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICB3MlJvdy5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICBbMSwgbnVtQ29scywgY29udkluZm8ub3V0Q2hhbm5lbHNdLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCLCBoYXNCaWFzLFxuICAgICAgZnVzZWRBY3RpdmF0aW9uLCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzLCBoYXNMZWFreXJlbHVBbHBoYSk7XG4gIGNvbnN0IGlucHV0czogVGVuc29ySW5mb1tdID0gW2ltMkNvbFJlc2hhcGVkLCB3MlJvd107XG4gIGlmIChiaWFzKSB7XG4gICAgaW5wdXRzLnB1c2goYmlhcyk7XG4gIH1cbiAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICBpbnB1dHMucHVzaChwcmVsdUFjdGl2YXRpb25XZWlnaHRzKTtcbiAgfVxuICBpZiAoaGFzTGVha3lyZWx1QWxwaGEpIHtcbiAgICBjb25zdCAkbGVha3lyZWx1QWxwaGEgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFxuICAgICAgICBbXSwgJ2Zsb2F0MzInLFxuICAgICAgICB1dGlsLmNyZWF0ZVNjYWxhclZhbHVlKGxlYWt5cmVsdUFscGhhIGFzIHt9IGFzICdmbG9hdDMyJywgJ2Zsb2F0MzInKSk7XG4gICAgaW5wdXRzLnB1c2goJGxlYWt5cmVsdUFscGhhKTtcbiAgICBpbnRlcm1lZGlhdGVzLnB1c2goJGxlYWt5cmVsdUFscGhhKTtcbiAgfVxuICBjb25zdCBwcm9kdWN0ID0gYmFja2VuZC5ydW5XZWJHTFByb2dyYW0obWF0bXVsUHJvZ3JhbSwgaW5wdXRzLCAnZmxvYXQzMicpO1xuXG4gIGNvbnN0IG91dEluTkhXQ0Zvcm1hdFNoYXBlID0gWzEsIG91dEhlaWdodCwgb3V0V2lkdGgsIGNvbnZJbmZvLm91dENoYW5uZWxzXTtcbiAgY29uc3Qgb3V0SW5OSFdDRm9ybWF0ID0gcmVzaGFwZShcbiAgICAgIHtpbnB1dHM6IHt4OiBwcm9kdWN0fSwgYmFja2VuZCwgYXR0cnM6IHtzaGFwZTogb3V0SW5OSFdDRm9ybWF0U2hhcGV9fSk7XG5cbiAgLy8gSWYgdGhlIGRhdGEgZm9ybWF0IGlzIE5DSFcsIHRoZW4gY29udmVydCB0aGUgb3V0cHV0IHRvIGJlIE5DSFcgZm9ybWF0LlxuICBjb25zdCBvdXQgPSBpc0NoYW5uZWxzTGFzdCA/XG4gICAgICBvdXRJbk5IV0NGb3JtYXQgOlxuICAgICAgdHJhbnNwb3NlKFxuICAgICAgICAgIHtpbnB1dHM6IHt4OiBvdXRJbk5IV0NGb3JtYXR9LCBiYWNrZW5kLCBhdHRyczoge3Blcm06IFswLCAzLCAxLCAyXX19KTtcbiAgaWYgKCFpc0NoYW5uZWxzTGFzdCkge1xuICAgIGludGVybWVkaWF0ZXMucHVzaChvdXRJbk5IV0NGb3JtYXQpO1xuICB9XG5cbiAgaW50ZXJtZWRpYXRlcy5wdXNoKHByb2R1Y3QpO1xuICBmb3IgKGNvbnN0IGkgb2YgaW50ZXJtZWRpYXRlcykge1xuICAgIGJhY2tlbmQuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIl19